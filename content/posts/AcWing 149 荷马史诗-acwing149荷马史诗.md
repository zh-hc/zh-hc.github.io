---
title: AcWing 149. 荷马史诗
date: 2022-08-05 02:57:57.493
updated: 2022-08-08 11:32:32.73
url: /p=48
categories: 
tags: 
- AcWing
- 考研算法
---

## 题目
追逐影子的人，自己就是影子。 ——荷马
达达最近迷上了文学。
她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。
但是由《奥德赛》和《伊利亚特》组成的鸿篇巨制《荷马史诗》实在是太长了，达达想通过一种编码方式使得它变得短一些。
一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_i$。
达达想要用 $k$ 进制串 $s_i$ 来替换第 $i$ 种单词，使得其满足如下要求:
对于任意的 $1≤i$,$j≤n$，$i≠j$，都有：$s_i$ 不是 $s_j$ 的前缀。
现在达达想要知道，如何选择 $s_i$，才能使替换以后得到的新的《荷马史诗》长度最小。
在确保总长度最小的情况下，达达还想知道最长的 $s_i$ 的最短长度是多少？
一个字符串被称为 $k$ 进制字符串，当且仅当它的每个字符是 $0$ 到 $k−1$ 之间（包括 $0$ 和 $k−1$）的整数。
字符串 $Str1$ 被称为字符串 $Str2$ 的前缀，当且仅当：存在 $1≤t≤m$，使得 $Str1=Str2[1..t]$。
其中，$m$ 是字符串 $Str2$ 的长度，$Str2[1..t]$ 表示 $Str2$ 的前 $t$ 个字符组成的字符串。
**注意**:请使用 $64$ 位整数进行输入输出、储存和计算。

**输入格式**
输入文件的第 $1$ 行包含 $2$ 个正整数 $n$,$k$，中间用单个空格隔开，表示共有 $n$ 种单词，需要使用 $k$ 进制字符串进行替换。
第 $2∼n+1$ 行：第 $i+1$ 行包含 $1$ 个非负整数 $w_i$，表示第 $i$ 种单词的出现次数。

**输出格式**
输出文件包括 $2$ 行。
第 $1$ 行输出 $1$ 个整数，为《荷马史诗》经过重新编码以后的最短长度。
第 $2$ 行输出 $1$ 个整数，为保证最短总长度的情况下，最长字符串 $s_i$ 的最短长度。

**数据范围**
$2≤n≤100000$,
$2≤k≤9$
$1≤w_i≤1012$

**输入样例：**
```
4 2
1
1
2
2
```

**输出样例：**
```
12
2
```

## 思路
**第一问：最小权值和**
> 本题是说我们使用的是`k叉树`，而不是`二叉树`，也就是说每一个节点都可能有`k个儿子`，所以如果直接按照二叉树的做法，每次合并最小的k个数最终可能会导致第一层树不满。

一共是 $n$ 个数，每次合并后减少 $k-1$ 个数，如果我们减少了 $m$ 次，那么有 $n-m(k-1)=1$ 时，我们就可以`恰好` 处理完所有节点，整理得 $n-1=m(k-1)$，也就是说，当 $(n-1)\%(k-1)=0$ 时，这个思路(每次合并最小的k个点)就是正确的。
- 那么当 $(n-1)\%(k-1)=x(x≠0)$ 时，我们就需要将思路做一点小小的改变：
	- 方法一：第一次合并 $x$ 个数，而不是合并 $k$ 个数，其他循环依然合并 $k$ 个数即可。
	- 方法二(等价的做法)：我们通过添加额外的0，使得 $(n-1)%(k-1)=0$。

**第二问：最深的结点的深度最小是多少**
当最后一层 $k$ 个数据严格的小于其他数的时候，我们可以确定最深节点就是由这 $k$ 个数字组成，但是如果有多于 $k$ 个相同的数字(即`权值相同`)，那么我们需要选择深度最小(也就是`已合并次数最少`)的节点。

## 题解
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef long long LL;
typedef pair<LL, int> PLI;

int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    priority_queue<PLI, vector<PLI>, greater<PLI>> heap;
    while (n -- )
    {
        LL w;
        scanf("%lld", &w);
        heap.push({w, 0});
    }
    while ((heap.size() - 1) % (k - 1)) heap.push({0, 0});

    LL res = 0;
    while (heap.size() > 1)
    {
        LL s = 0;
        int depth = 0;
        for (int i = 0; i < k; i ++ )
        {
            auto t = heap.top();
            heap.pop();
            s += t.x, depth = max(depth, t.y);
        }
        heap.push({s, depth + 1});
        res += s;
    }

    printf("%lld\n%d\n", res, heap.top().y);
    return 0;
}
```