<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>浅谈单源Bellman-Ford最短路径算法 | baymin</title>
<link rel="shortcut icon" href="https://blog.baymin.eu.org/favicon.ico?v=1658276127496">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.baymin.eu.org/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="浅谈单源Bellman-Ford最短路径算法 | baymin - Atom Feed" href="https://blog.baymin.eu.org/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="算法说明

Bellman-Ford 算法是一种用于计算带权有向图中单源最短路径（SSSP：Single-Source Shortest Path）的算法。
对于带权有向图 G = (V, E)，Dijkstra 算法要求图 G 中边的权值..." />
    <meta name="keywords" content="学习" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.baymin.eu.org">
  <img class="avatar" src="https://blog.baymin.eu.org/images/avatar.png?v=1658276127496" alt="">
  </a>
  <h1 class="site-title">
    baymin
  </h1>
  <p class="site-description">
    一蓑烟雨任平生
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/post/link" class="menu">
          书签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              浅谈单源Bellman-Ford最短路径算法
            </h2>
            <div class="post-info">
              <span>
                2022-06-18
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://blog.baymin.eu.org/tag/learning/" class="post-tag">
                  # 学习
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="算法说明">算法说明</h2>
<ul>
<li>Bellman-Ford 算法是一种用于计算带权有向图中单源最短路径（SSSP：Single-Source Shortest Path）的算法。</li>
<li>对于带权有向图 G = (V, E)，Dijkstra 算法要求图 G 中边的权值均为非负，而Bellman-ford能适应一般的情况（即存在负权边的情况）。</li>
<li>Bellman-ford 采用动态规划的方法，实现的时间复杂度为 O(V*E)，其中 V 为顶点数量，E 为边的数量。</li>
<li>Dijkstra 算法采用贪心算法的方法，普通实现的时间复杂度为 O(V^2)。若使用优先队列则时间复杂度为 O(E + VlogV)。</li>
</ul>
<h2 id="bellman-ford-算法描述">Bellman-Ford 算法描述</h2>
<ol>
<li>创建源顶点 v 到图中所有顶点的<strong>距离</strong>的集合 distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为 0；</li>
<li>计算最短路径，执行 V - 1 次遍历；
<ul>
<li>对于图中的<strong>每条边</strong>：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；(即松弛操作)</li>
</ul>
</li>
<li>检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p><strong>字母定义</strong><br>
G：图<br>
w：权重二维数组，反映的是u到v的边的权重。<br>
s：起点</p>
<p><strong>for循环解释</strong><br>
第一个双重for循环：循环V - 1次，对于每个边，都进行松弛操作；<br>
第二个for循环：检查是否有环。</p>
<ul>
<li>因为已经进行了V-1次循环了，理论上不应该可以松弛；</li>
<li>但如果还有可以松弛的，说明存在负权环，返回False，否则返回true。</li>
</ul>
<p><strong>为什么要循环V-1次？</strong><br>
因为最短路径肯定是个简单路径，不可能包含回路，如果包含回路，但回路的权值和为正，也松弛不了，还是可以得到更短的路径。但如果回路的权值是负的，就可以一直松弛，那么肯定没有解。图有n个点，又不能有回路，所以最短路径最多n-1边（可以想象成一条线）。又因为每次循环至少松弛一条边，所以最多n-1次就行了。</p>
<h3 id="bellman-ford">Bellman-ford</h3>
<pre><code class="language-C">// BELLMAN-FORD(G, w, s)
INITIALIZE-SINGLE-SOURCE(G, s)
// 初始化
for all u ∈ V
    d[u] = ∞
    π[u] = nil
d[s] = 0
// 松弛操作
for i = 1 to |V[G]| - 1
    for each edge (u, v) ∈ E[G]
        RELAX(u, v, w)
// 检查是否存在负权环
for each edge (u, v) ∈ E[G]
    if d[v] &gt; d[u] + w(u, v)
        then return FALSE
return TRUE
</code></pre>
<h3 id="松弛操作">松弛操作</h3>
<pre><code class="language-C">// 对u节点到v节点的距离进行的松弛操作，如果到u的距离加上u到v的边小于到v的距离，那么可以缩短距离，更新之。
// RELAX(u, v, w)
if d[v] &gt; d[u] + w(u, v)
    d[v] = d[u] + w(u, v)
    π[v] = u // 前置数组 原本被初始化为空 用于存储当前路径的上一个点是什么
</code></pre>
<h2 id="例子">例子</h2>
<figure data-type="image" tabindex="1"><img src="https://blog.baymin.eu.org/post-images/1655601009179.png" alt="" loading="lazy"></figure>
<ol>
<li>初始化：源节点到自己的距离为0，到其他节点的距离为∞；</li>
<li>对于源节点的<code>邻接节点</code>，比较<code>从源节点加上边的和</code>与其<code>本身距离</code>的值，若小，则更新。以此类推，循环 V - 1 次（即节点数减1次）。</li>
<li>最后检查是否还可以松弛，如果可以，说明有环，返回false。</li>
</ol>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E">算法说明</a></li>
<li><a href="#bellman-ford-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0">Bellman-Ford 算法描述</a></li>
<li><a href="#%E4%BC%AA%E4%BB%A3%E7%A0%81">伪代码</a>
<ul>
<li><a href="#bellman-ford">Bellman-ford</a></li>
<li><a href="#%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C">松弛操作</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.baymin.eu.org/post/yu-2022-nian-6-yue-18-ri/">
              <h3 class="post-title">
                于2022年6月18日
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  <a href="https://time.is/Beijing" id="time_is_link" rel="nofollow" style="font-size:12px">北京时间:</a>
<span id="Beijing_z43d" style="font-size:12px"></span>
<script src="//widget.time.is/zh.js"></script>
<script>
time_is_widget.init({Beijing_z43d:{template:"TIME<br>DATE<br>SUN", date_format:"year-monthnum-daynumdayname", sun_format:"日出: srhour:srminute 日落: sshour:ssminute<br>昼长: dlhours时 dlminutes分", coords:"39.9075000,116.3972300"}});
</script>
  <a class="rss" href="https://blog.baymin.eu.org/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
