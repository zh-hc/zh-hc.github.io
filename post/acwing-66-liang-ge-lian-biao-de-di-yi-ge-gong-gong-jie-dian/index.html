<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AcWing 66. 两个链表的第一个公共结点 | baymin</title>
<link rel="shortcut icon" href="https://blog.baymin.eu.org/favicon.ico?v=1658276127496">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.baymin.eu.org/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="AcWing 66. 两个链表的第一个公共结点 | baymin - Atom Feed" href="https://blog.baymin.eu.org/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="题目
输入两个链表，找出它们的第一个公共结点。
当不存在公共节点时，返回空节点。
数据范围
链表长度[1,2000]。
样例
给出两个链表如下所示：
A：        a1 → a2
                   ↘
      ..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.baymin.eu.org">
  <img class="avatar" src="https://blog.baymin.eu.org/images/avatar.png?v=1658276127496" alt="">
  </a>
  <h1 class="site-title">
    baymin
  </h1>
  <p class="site-description">
    一蓑烟雨任平生
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/post/link" class="menu">
          书签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              AcWing 66. 两个链表的第一个公共结点
            </h2>
            <div class="post-info">
              <span>
                2022-07-19
              </span>
              <span>
                3 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="题目">题目</h2>
<p>输入两个链表，找出它们的第一个公共结点。<br>
当不存在公共节点时，返回空节点。</p>
<p><strong>数据范围</strong><br>
链表长度<code>[1,2000]</code>。</p>
<p><strong>样例</strong></p>
<pre><code>给出两个链表如下所示：
A：        a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3

输出第一个公共节点c1
</code></pre>
<h2 id="备注">备注</h2>
<p><strong>本题调试框内输入输出的含义</strong><br>
如果大家打算在调试框内构造输入输出，格式如下：<br>
输入包括三行，例如：</p>
<pre><code>[a, b, c, d, e]
[f, g, h]
3
</code></pre>
<p>表示的两个链表分别是：</p>
<ul>
<li>第一个链表即输入第一行的链表：<code>[a, b, c, d, e]</code></li>
<li>第二个链表即将输入第二行的链表接到第一行链表的第3个节点后面（链表节点下标从1开始）：<code>[a, b, c, f, g, h]</code></li>
<li>如果输入第三行为-1，表示两个链表不相交，此时第二个链表即输入第二行的链表：<code>[f, g, h]</code><br>
输出包括一行：</li>
<li>如果两个链表相交，则输出相交节点的权值，即<code>c</code>；</li>
<li>如果不相交，则输出<code>null</code></li>
</ul>
<h2 id="巧妙的思路">巧妙的思路</h2>
<p>一共有两种情况，第一种情况是两个链表存在公共结点，第二种情况是两个链表不存在公共结点。<br>
如图所示，我们定义两个指针p、q，同时定义每一个指针的路线，其中：</p>
<ul>
<li>p指针从第一个链表的起点出发，到达第一个链表尾部(即空结点)后，转到第二个链表起点继续前进，直到和q指针相遇为止(也就是p和q相等)</li>
<li>q指针从第二个链表的起点出发，到达第二个链表尾部(即空结点)后，转到第一个链表起点继续前进，直到和p指针相遇为止(也就是p和q相等)</li>
</ul>
<p>我们将距离分别设置为如图所示的a、b、c，那么:</p>
<ul>
<li>当两个链表存在公共结点时，两个指针p、q走过的路径长度分别为：<code>a+c+b</code>、<code>b+c+a</code>，走过的总长度相同。</li>
<li>当两个链表不存在公共结点时，两个指针p、q走过的路径长度分别为：<code>a+b</code>、<code>b+a</code><br>
<img src="https://blog.baymin.eu.org/post-images/1658200600657.png" alt="" loading="lazy"></li>
</ul>
<h2 id="题解">题解</h2>
<pre><code class="language-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *findFirstCommonNode(ListNode *headA, ListNode *headB) {
        auto p = headA, q = headB;
        while (p != q) {
            p = p ? p-&gt;next : headB;
            q = q ? q-&gt;next : headA;
        }
        return p;
    }
};
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a href="#%E5%A4%87%E6%B3%A8">备注</a></li>
<li><a href="#%E5%B7%A7%E5%A6%99%E7%9A%84%E6%80%9D%E8%B7%AF">巧妙的思路</a></li>
<li><a href="#%E9%A2%98%E8%A7%A3">题解</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.baymin.eu.org/post/acwing-3374-jin-zhi-zhuan-huan-2/">
              <h3 class="post-title">
                AcWing 3374. 进制转换2
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  <a href="https://time.is/Beijing" id="time_is_link" rel="nofollow" style="font-size:12px">北京时间:</a>
<span id="Beijing_z43d" style="font-size:12px"></span>
<script src="//widget.time.is/zh.js"></script>
<script>
time_is_widget.init({Beijing_z43d:{template:"TIME<br>DATE<br>SUN", date_format:"year-monthnum-daynumdayname", sun_format:"日出: srhour:srminute 日落: sshour:ssminute<br>昼长: dlhours时 dlminutes分", coords:"39.9075000,116.3972300"}});
</script>
  <a class="rss" href="https://blog.baymin.eu.org/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
